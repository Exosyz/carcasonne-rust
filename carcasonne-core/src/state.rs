use crate::action::Action;
use crate::input_handler::InputEvent;
use crate::layout::node::Node;

pub mod game_state;

/// Represents the possible outcomes after processing a state update.
///
/// This enum is used to control the flow of state transitions in the application.
pub enum StateResult {
    /// Skip further processing or updates in the current cycle.
    Skip,
    /// Continue with a new state, replacing the current one.
    ///
    /// The boxed `State` will become the active state.
    Continue(Box<dyn State>),
    /// Exit the current state machine or application gracefully.
    ExitToStop,
}

/// Represents a state in the application or game.
///
/// This trait defines a state as part of a state machine, commonly used in games or interactive
/// applications. Each state is responsible for handling user input, updating its logic,
/// and rendering itself.
///
/// The typical workflow for a state looks like this:
/// 1. `handle_input` is called to process user input events and produce an `Action`.
/// 2. `update` is called with the produced `Action` to update the state or transition to a new state.
/// 3. `render` is called to draw the current state.
///
/// This design allows clean separation of input handling, state transitions, and rendering logic.
pub trait State {
    /// Updates the current state based on the provided `Action`.
    ///
    /// This method processes the provided action, updates the stateâ€™s internal logic,
    /// and optionally returns a new `State` to transition into.
    ///
    /// # Arguments
    ///
    /// * `action` - The action generated by `handle_input` to process.
    ///
    /// # Returns
    ///
    /// An optional boxed `State` to transition into.
    /// If `None` is returned, the current state remains active.
    fn update(&mut self, action: Action) -> StateResult;

    /// Produces a layout tree representing the current visual state.
    ///
    /// This method returns the root `Node` of the layout that should be rendered.
    /// It allows separating the logic that generates the UI structure from the rendering itself.
    ///
    /// # Returns
    ///
    /// A `Node` representing the complete layout to draw.
    fn draw(&self) -> Node;

    /// Handles a user input event and produces an `Action`.
    ///
    /// This method processes input events (e.g., keyboard, mouse) and determines
    /// the corresponding action that should be performed.
    ///
    /// # Arguments
    ///
    /// * `event` - The input event to handle.
    ///
    /// # Returns
    ///
    /// An `Action` describing how the state should react to the event.
    fn handle_input(&self, event: InputEvent) -> Action;

    /// Indicates whether the component requires user input to proceed.
    ///
    /// Returns `true` if the component expects input (e.g., waiting for a key press),
    /// or `false` if it can continue without user interaction.
    ///
    /// # Returns
    ///
    /// A boolean indicating input requirement (`true` means input needed).
    fn need_input(&self) -> bool {
        false
    }
}
